#!/usr/bin/env python3
# encoding=UTF-8

# Copyright © 2022-2025 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import enum
import os
import re
import subprocess
import sys

import elftools.elf.elffile
elflib = elftools.elf

lambda x, /: x  # Python >= 3.8 is required

def attr2func(f):
    class attr2func:
        def __getattr__(self, name):
            return f(name)
    return attr2func()

def _gen_regexps():
    x = attr2func(lambda name: fr'(?P<{name}>[0-9a-f]+)')
    pid = r'\[\d+\]'
    # print_vma_addr() in <mm/memory.c>
    vma = fr'(?P<elf>\S+)\[(?:{x.relip},)?{x.vmstart}[+]{x.vmsize}\]'
    yield (
        # show_signal() in <arch/x86/kernel/traps.c>:
        fr'{pid} (?:trap )?(?P<type>.*) ip:{x.ip} sp:{x.sp} error:{x.err} in {vma}'
    )
    yield (
        # show_signal_msg() in <arch/x86/mm/fault.c>:
        fr'{pid}: (?P<type>segfault) at {x.at} ip {x.ip} sp {x.sp} error {x.err} in {vma}'
    )

regexps = [re.compile(r) for r in _gen_regexps()]

class Addr(int):

    def __new__(cls, addr):
        if isinstance(addr, str):
            addr = int(addr, 16)
        return super().__new__(cls, addr)

    def __add__(self, other):
        return Addr(super().__add__(other))

    def __sub__(self, other):
        return Addr(super().__sub__(other))

    def __str__(self):
        return f'0x{self:012X}'

class PFErrorCode(enum.IntFlag):

    # enum x86_pf_error_code in <arch/x86/include/asm/trap_pf.h>:
    X86_PF_PROT  = 1 << 0   # 0 = no page found; 1 = protection fault
    X86_PF_WRITE = 1 << 1   # 0 = read access; 1 = write access
    X86_PF_USER  = 1 << 2   # 0 = kernel-mode access; 1 = user-mode access
    X86_PF_RSVD  = 1 << 3   # use of reserved bit detected
    X86_PF_INSTR = 1 << 4   # fault was an instruction fetch
    X86_PF_PK    = 1 << 5   # protection keys block access
    X86_PF_SGX   = 1 << 15  # SGX MMU page-fault
    X86_PF_RMP   = 1 << 31  # RMP violation

    # TODO: automatically verify the enum
    # is in sync with the kernel

    def __str__(self):
        names = []
        n = int(self)
        for i in type(self):
            if i & n:
                n -= i
                names += [i.name]
        if n:
            names += [str(n)]
        return str.join(' | ', names)

def fmt_err(err):
    if isinstance(err, str):
        err = int(err, 16)
    return f'0x{err:08X}'

def fmt_pf_err(err):
    if isinstance(err, str):
        err = int(err, 16)
    s = f'0x{err:04X}'
    if err != 0:
        err = PFErrorCode(err)
        s += f' ({err})'
    return s

bland_types = {  # error code is always 0
    'divide error', # DE
    'overflow', # OF
    'invalid opcode', # UD
    'coprocessor segment overrun', # (not found in the wild)
    'bounds', # BR
    'int3', # BP
    'iret exception',
    'alignment check', # AC
    # Sources:
    # * <arch/x86/kernel/traps.c>
    # * "Intel 64 and IA-32 Architectures Software Developer’s Manual
    #    Volume 3A: System Programming Guide",
    #    Table 6-1 "Protected-Mode Exceptions and Interrupts"
}

def align_down(n, a):
    return n & ~(a - 1)

def align_up(n, a):
    return (n + a - 1) & ~(a - 1)

page_size = os.sysconf('SC_PAGE_SIZE')
# FIXME? This assumes that page size for the crashed program
# is the same as ours.

def get_segments(elf_path, *, size, offset=None):
    with open(elf_path, 'rb') as fp:
        elffile = elflib.elffile.ELFFile(fp)
        for segment in elffile.iter_segments('PT_LOAD'):
            if offset is not None:
                if 0 <= offset - segment['p_offset'] < segment['p_filesz']:
                    yield segment
                    return
            elif segment['p_flags'] & elflib.constants.P_FLAGS.PF_X:
                offset = segment['p_offset']
                map_start = align_down(offset, page_size)
                map_end = align_up(offset + segment['p_memsz'], page_size)
                if map_end - map_start == size:
                    yield segment

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('-e', dest='elf', metavar='PATH', help='ELF file to look into')
    opts = ap.parse_args()
    prog = ap.prog
    n = 0
    for line in sys.stdin:
        for regexp in regexps:
            match = regexp.search(line)
            if match is not None:
                break
        else:
            print(f'{prog}: cannot parse:', line.rstrip('\n'), file=sys.stderr)
            continue
        g = attr2func(match.group)
        if n > 0:
            print()
        print('Type:', g.type)
        err = g.err
        if g.type in bland_types:
            assert err == '0'
            err = None
        if g.type == 'segfault':
            print('Error:', fmt_pf_err(err))
        elif err is not None:
            print('Error:', fmt_err(err))
        try:
            at = g.at
        except IndexError:
            pass
        else:
            print('At:', Addr(at))
        print('SP:', Addr(g.sp))
        elf = g.elf
        if opts.elf:
            elf = opts.elf
        print('Path:', elf)
        ip = Addr(g.ip)
        relip = None
        relip_info = []
        if g.relip:
            relip = Addr(g.relip)
            relip_info = ['= ELF +', relip]
        vmstart = Addr(g.vmstart)
        vmsize = Addr(g.vmsize)
        print('IP:', ip, '=', 'VMA +', ip - vmstart, *relip_info)
        print('VMA at:', vmstart)
        print('VMA size:', vmsize)
        if opts.elf:
            xsegments = get_segments(opts.elf, size=vmsize, offset=relip)
            xsegments = list(xsegments)
            n_xsegments = len(xsegments)
            if n_xsegments == 1:
                [xsegment] = xsegments
                elf_vaddr = xsegment['p_vaddr']
                if relip is not None:
                    elf_faddr = xsegment['p_offset']
                    addr = relip - elf_faddr + elf_vaddr
                else:
                    addr = ip - vmstart + align_down(elf_vaddr, page_size)
                print('Source:', end=' ', flush=True)
                cmdline = ['addr2line', '-e', elf, '-f', '-i', '-p', '-C', str(addr)]
                subprocess.run(cmdline, check=True)
            else:
                if n_xsegments == 0:
                    n_xsegments = 'no'
                print(f'Source: ?? (found {n_xsegments} matching segments)')
        n += 1
    sys.exit(n == 0)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
